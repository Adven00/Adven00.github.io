<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Next Event Estimation</title>
    <link href="/2023/11/27/Next-Event-Estimation/"/>
    <url>/2023/11/27/Next-Event-Estimation/</url>
    
    <content type="html"><![CDATA[<p>Next Event Estimation (NEE)是一个常被提及的概念，却鲜有中文资料介绍。受<ahref="https://zhuanlan.zhihu.com/p/666466161">这篇文章</a>启发，我姑且将NEE 定义为「提前计算直接光照」。这一概念常常和 MIS等混淆，特此整理一下。</p><h2 id="算法">算法</h2><p>首先还是列出渲染方程</p><p><span class="math display">\[L(x\to\omega_i) = L_e(x\to\omega_i) + \int_\Omega L(\omega\tox)f_s(\omega\to x \to \omega_i)\cos\theta d \omega\]</span></p><p>渲染方程带有递归性质，实质上是直接光照 <spanclass="math inline">\(L_e\)</span> 的累加</p><p><span class="math display">\[L(x^0\to\omega^0)=\sum_i K_i L_e(x^i\to\omega^i)\]</span></p><p>其中上标代表一条追踪路径 <spanclass="math inline">\(x^0\to\omega^0\to x^1\to\omega^1\to\cdots\)</span>，到这里其实就可以写出一个简单的路径追踪函数了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">function <span class="hljs-title">Li</span><span class="hljs-params">(dir)</span>:</span><br><span class="hljs-function">    throughoutput =</span> <span class="hljs-number">1</span><br>    radiance = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span>(before max depth)<br>        x = scene.<span class="hljs-built_in">Intersect</span>(dir)<br><br>        <span class="hljs-keyword">if</span> (x is on a light)<br>            radiance += <span class="hljs-built_in">Le</span>(x, dir) * throughoutput<br><br>        dir, pdf, cos, bsdf = <span class="hljs-built_in">SmapleNextDirection</span>()<br>        throughoutput *= bsdf * cos / pdf <br><br>    <span class="hljs-keyword">return</span> radiance<br></code></pre></td></tr></table></figure><p>这里采样下一条路径的方法是任意的，可以根据材质等等。思路很简洁，但存在一个问题：当且仅当采样的路径击中光源表面时，才会对该光线的结果产生贡献。在光源较少的场景里这并不是一件容易的事！当然只要光线足够多，迭代足够深，总会得到收敛的结果，但也会导致较大的方差。</p><p>换句话说，造成该现象的原因是「计算光源贡献的时机太迟了」，非要到直接击中时才计算。事实上，我们可以将交点受到的光照拆成两部分：光源直接照射和其他表面的散射</p><p><span class="math display">\[L(\omega\to x)=L_e(\omega\to x) + L_s(\omega\to x)\]</span></p><p>把渲染方程改写成</p><p><span class="math display">\[\begin{aligned}L_s(x\to\omega_i) =&amp;\int_\Omega L_s(\omega\to x)f_s(\omega\to x \to\omega_i)\cos\theta d \omega \qquad\text{(indirect light)}\\+&amp;\int_{\Omega_e}L_e(\omega\to x)f_s(\omega\to x \to\omega_i)\cos\theta d \omega\qquad\text{ (direct light)}    \end{aligned}\]</span></p><p>这样改写以后，和原来的渲染方程形式上几乎一致，区别在于 <spanclass="math inline">\(L_e\)</span> 项变成了一个关于 <spanclass="math inline">\(L_e\)</span>的积分。这样，每次击中表面时，都会计算「受到的直接光照的积分」，即使是小光源也总会产生贡献。从「表面发出的光」到「受到的直接光照积分」，将后续直接光的计算提前，这就是我对「NextEvent」的理解。</p><p>计算上式是很简单的，和前述原始渲染方程的计算方法完全相同，只不过把<span class="math inline">\(L_e\)</span>换成一个可计算的积分。第二项直接光积分更常见的形式是</p><p><span class="math display">\[\begin{aligned}\int_{A}L_e(p\to x)f_s(p\to x \to \omega_i)G(x,p)dA\\G(x,p)=V(x\leftrightarrow p)\frac{\cos\theta_1\cos\theta_2}{\lVertp-x\rVert^2}\end{aligned}\]</span></p><p>采样域转化到面上计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">function <span class="hljs-title">Ls</span><span class="hljs-params">(dir)</span>:</span><br><span class="hljs-function">    throughoutput =</span> <span class="hljs-number">1</span><br>    radiance = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">while</span>(before max depth)<br>        x = scene.<span class="hljs-built_in">Intersect</span>(dir)<br><br>        pdf_direct, bsdf_direct, emittance, geo_term = <span class="hljs-built_in">SampleLight</span>()<br>        direct_radiance = bsdf_direct * emittance * geo_term / pdf_direct<br>        radiance += direct_radiance * throughoutput<br><br>        dir, pdf, cos, bsdf = <span class="hljs-built_in">SmapleNextDirection</span>()<br>        throughoutput *= bsdf * cos / pdf<br><br>    <span class="hljs-keyword">return</span> radiance<br></code></pre></td></tr></table></figure><p>注意一个细节，这里计算的是 <span class="math inline">\(L_s\)</span>而非 <span class="math inline">\(L_i\)</span>，如果从相机发出的光线所交的第一个表面就有光照 <spanclass="math inline">\(L_e\)</span>，要加到结果上。因为第一个表面的直接光照已经没法再提前计算了。</p><h2 id="和多重重要性采样mis的关系">和多重重要性采样（MIS）的关系</h2><p>可能会有人和我有过一样的疑问：这不就是 MIS中的对光源采样吗，何必专门去说？</p><p>事实上，我所做的不过是将 <span class="math inline">\(L\)</span> 拆成<span class="math inline">\(L_s\)</span> 和 <spanclass="math inline">\(L_e\)</span> ，改写渲染方程的形式，得到 NEE的计算框架。至于采样无非是计算积分的方式，和 NEE本身并无关联，这是非常容易混淆的。</p><p>在 NEE 下应用 MIS 的计算对象是积分 <span class="math display">\[\begin{aligned}E(\omega)=&amp;\int_{\Omega_e} L_e(\omega\to x)f_s(\omega\to x \to\omega_i)\cos\theta d \omega\\E(p)=&amp;\int_{\Omega_e}L_e(p\to x)f_s(p\to x \to \omega_i)G(x,p)dp\end{aligned}\]</span> 可以将积分域延拓到 <span class="math inline">\(\Omega\)</span>上（没有直接光照的地方 <spanclass="math inline">\(L_e=0\)</span>），再根据材质做重要性采样，并和光源重要性采样的结果加权平均。注意到根据光源采样和根据材质采样的采样域是不一样的，但并不影响结果的无偏性，有关MIS 性质的证明可以参考<ahref="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/">这篇文章</a>，结果是<span class="math display">\[\hat{E}=W(\omega_s)\frac{E(\omega_s)}{pdf(\omega_s)}+W(p_s)\frac{E(p_s)}{pdf(p_s)}\]</span></p><p>可以复用样本 <span class="math inline">\(\omega_s\)</span>采样间接光积分。权重函数此处不予赘述。</p><p>为什么只对 NEE 中的直接光积分使用 MIS？因为直接光积分的计算不存在递归，如果直接对原始渲染方程中的积分使用 MIS<span class="math display">\[\int_\Omega L(\omega\to x)f_s(\omega\to x \to \omega_i)\cos\theta d\omega\]</span>当然也可以根据光源和材质采样出两条路径，但这两条路径都需要递归计算，会导致光线数以指数级别增长，是不可接受的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>渲染方程的级数形式</title>
    <link href="/2022/01/14/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%9A%84%E7%BA%A7%E6%95%B0%E5%BD%A2%E5%BC%8F/"/>
    <url>/2022/01/14/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E7%9A%84%E7%BA%A7%E6%95%B0%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>首先，给出一般的「渲染方程」</p><p><span class="math display">\[L_o(x, \omega_o)=L_e(x, \omega_o)+\int_{\Omega}f_r(x, \omega_o,\omega_i)L_i(x, \omega_i)\cos \theta d\omega_i\]</span></p><p>这个方程显然带有递归性质：从 <span class="math inline">\(x\)</span>点射出的光线 <span class="math inline">\(L_o\)</span>又会成为射入下一个交点 <span class="math inline">\(x^{&#39;}\)</span>的入射光线</p><p><span class="math display">\[L_o(x, \omega_o)=L_i(x^{&#39;},-\omega_o)\]</span></p><p>在对一条光路进行「路径追踪」时，要递归多次以计算出最终进入相机的<span class="math inline">\(L_o\)</span> ，将 <spanclass="math inline">\(L_o\)</span> 其记作 <spanclass="math inline">\(L_i^{0}\)</span>，上标表示递归的层级。</p><p>再看方程的积分项。路径追踪中，利用「蒙特卡洛积分」将积分项化成单纯的乘法运算，表示如下</p><p><span class="math display">\[\int_{\Omega}f_rL_i\cos \theta d\omega_i\approx f_rL_i\cos\theta/p(\omega_i)=kL_i\]</span></p><p>综上，把渲染方程写成</p><p><span class="math display">\[L_i^n=L_e^n+k_nL_i^{n+1}\]</span></p><p>由这个递推关系，展开最后的结果 <spanclass="math inline">\(L_i^0\)</span>，记 <spanclass="math inline">\(K_n=\prod \limits_{i=0}^{n-1}k_i\)</span></p><p><span class="math display">\[\begin{aligned}L_i^0&amp;=L_e^0+k_0L_e^1+k_0k_1L_e^2+k_0k_1k_2L_e^3+\cdots\\&amp;=L_e^0+K_1L_e^1+K_2L_e^2+K_3L_e^3+\cdots\\&amp;=\sum\limits_{i=0}^{+\infty}K_iL_e^i\end{aligned}\]</span></p><p>上式就是我们在「路径追踪」中实际使用的计算公式，这是一个单调收敛的无穷项级数，一般还要用「俄罗斯轮盘赌」方法控制项数。做这样的的变换有利于我们在编程时将渲染过程写成迭代而非递归。</p><p>此外，观察这个公式，可以对渲染方程有更深的理解：所有进入相机的光线源头都是<span class="math inline">\(L_e\)</span> ， <spanclass="math inline">\(L_e^0\)</span> 是直接光照， <spanclass="math inline">\(K_1L_e^1\)</span>是经过一次折射或反射的间接光照，一般光栅化管线处理到这里为止。利用路径追踪，我们可以继续计算这个级数的更多项以得到「全局光照」。</p><p>如果更深一步，把渲染方程抽象成线性算子形式</p><p><span class="math display">\[\begin{aligned}L=E+KL\end{aligned}\]</span></p><p>可以展开为</p><p><span class="math display">\[L=(1-K)^{-1}E=E(1+K+K^2+\cdots)\]</span></p><p>思路上和我一致，只不过我是在更具体的情形下推导的，没有这么抽象，看看就好。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图形学渲染方向学习路线整理</title>
    <link href="/2021/12/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E6%96%B9%E5%90%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%95%B4%E7%90%86/"/>
    <url>/2021/12/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E6%96%B9%E5%90%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>个人经验总结，仅供参考。</p><h2 id="图形学基础">图形学基础</h2><ul><li><p><ahref="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101:现代计算机图形学入门 -UCSB 闫令琪</a></p><blockquote><p>感谢「孙小磊」的<ahref="https://www.zhihu.com/column/c_1249465121615204352">笔记</a></p></blockquote></li><li><p><ahref="http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm">什么是计算机图形学?-中国科学技术大学 刘利刚</a></p></li><li><p><ahref="http://staff.ustc.edu.cn/~lgliu/Courses/ComputerGraphics_2020_spring-summer/default.htm">计算机图形学-中国科学技术大学 刘利刚</a></p></li><li><p><a href="https://book.douban.com/subject/26868819/">Fundamentalsof Computer Graphics</a></p></li></ul><h2 id="实践软光栅">实践：软光栅</h2><ul><li><p><ahref="https://www.zhihu.com/question/24786878/answer/1483055155">如何开始用C++ 写一个光栅化渲染器？</a></p></li><li><p><a href="https://github.com/ssloy/tinyrenderer/wiki">Tinyrenderer or how OpenGL works: software rendering in 500 lines ofcode</a></p></li></ul><blockquote><p>知乎该问题下有很多优秀的开源实现和设计思路供参考</p></blockquote><h2 id="实践光线追踪">实践：光线追踪</h2><ul><li><p><a href="https://raytracing.github.io/">Ray Tracing in OneWeekend Series</a></p><blockquote><p>感谢「陈泽日天」的<ahref="https://zhuanlan.zhihu.com/p/128582904">翻译</a></p></blockquote></li><li><p><a href="https://wjakob.github.io/nori/#">Nori: an educationalray tracer</a></p><blockquote><p>感谢「ksg fk」的<ahref="https://www.zhihu.com/column/c_1407025850030698496">笔记</a></p></blockquote></li></ul><h2 id="渲染进阶">渲染进阶</h2><ul><li><p><a href="https://www.pbr-book.org/3ed-2018/contents">PhysicallyBased Rendering: From Theory To Implementation</a></p><blockquote><p>这里有一些<a href="https://dezeming.top/?page_id=50">笔记</a>和<ahref="https://www.zhihu.com/question/309420057/answer/652338038">阅读建议</a>。感谢毛星云的<ahref="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/media/PBR-White-Paper-Knowledge-Architecture-1.0.png">架构图</a></p></blockquote></li><li><p><a href="https://www.realtimerendering.com/">Real-TimeRendering</a></p><blockquote><p>感谢毛星云的<ahref="https://zhuanlan.zhihu.com/p/26259772">整理</a>与翻译，这里是他的<ahref="https://www.zhihu.com/column/game-programming">专栏</a></p></blockquote><blockquote><p>斯人已逝，薪火长存</p></blockquote></li><li><p><ahref="https://space.bilibili.com/1598639097/video">计算机图形学前沿暑期课程-中国科学技术大学</a></p></li><li><p><ahref="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">GAMES202:高质量实时渲染 -UCSB 闫令琪</a></p></li><li><p><a href="https://www.realtimerendering.com/raytracinggems/">RayTracing Gems Series</a></p><blockquote><p>感谢「Vinjn张静」组织的<ahref="https://item.jd.com/10037028085354.html">翻译</a></p></blockquote></li><li><p><a href="https://space.bilibili.com/512313464">GAMES Webinar在线报告</a></p><blockquote><p>渲染专题和绘制专题有很多值得一看的报告</p></blockquote></li><li><p><a href="https://kesen.realtimerendering.com/">SIGGRAPHresource</a></p></li></ul><h2 id="绘制流水线api">绘制流水线/API</h2><ul><li><p><a href="https://learnopengl-cn.github.io/">Learn OpenGLCN</a></p></li><li><p><a href="https://vulkan-tutorial.com/">Vulkan Tutorial</a></p><blockquote><p>感谢「fangcun」的<ahref="https://github.com/fangcun010/VulkanTutorialCN">翻译</a></p></blockquote></li><li><p><a href="https://zju-rendering.github.io/games106/">GAMES106:现代图形绘制流水线原理与实践</a></p></li><li><p><ahref="https://space.bilibili.com/2055684362/channel/collectiondetail?sid=318149">上帝视角看GPU-龚敏敏</a></p></li></ul><h2 id="编程">编程</h2><ul><li><p><a href="https://github.com/ttroy50/cmake-examples">CMakeExamples</a></p></li><li><p><ahref="https://google.github.io/styleguide/cppguide.html">Google C++Style Guide</a></p></li><li><p><a href="https://changkun.de/modern-cpp/">现代 C++ 教程：高速上手C++ 11/14/17/20</a></p></li><li><p><a href="https://github.com/parallel101/course">parallel101:高性能并行编程与优化 -彭于斌</a></p></li></ul><h2 id="游戏开发相关">游戏开发相关</h2><ul><li><p><ahref="https://github.com/miloyip/game-programmer/">游戏程序员的学习之路-叶劲峰</a></p></li><li><p><ahref="https://space.bilibili.com/7398208/video">技术美术百人计划</a></p></li><li><p><a href="https://games104.boomingtech.com/">GAMES104:现代游戏引擎 -不鸣科技 王希</a></p></li><li><p><a href="https://catlikecoding.com/unity/tutorials/">C# andShader Tutorials for the Unity Engine</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
